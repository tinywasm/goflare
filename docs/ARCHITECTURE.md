# GoFlare Build Architecture Summary

This docum#### Common Files (Both Workers & Pages)
| File | Purpose | Source |
|------|---------|--------|
| `app.wasm` | Compiled Go binary | tinywasm output |

#### Workers-Specific Files
| File | Purpose | Source |
|------|---------|--------|
| `wasm_exec.js` | WebAssembly runtime (Go class) | Go/TinyGo toolchain |
| `runtime.mjs` | Cloudflare context provider | Generated template |
| `worker.mjs` | Main worker logic | Generated template |

#### Pages-Specific Files
| File | Purpose | Source |
|------|---------|--------|
| `_worker.js` | Combined worker (wasm_exec + runtime + logic) | Generated template |vides an overview of the build process for both Cloudflare Workers and Pages Functions in the GoFlare package.

## Architecture Overview

GoFlare generates JavaScript wrapper files that enable Go WebAssembly applications to run on Cloudflare's edge platform. It leverages the `tinywasm` package for WASM compilation and handles the generation of runtime-specific wrapper files.

```
┌─────────────────┐
│   Go Source     │
│   (main.go)     │
└────────┬────────┘
         │
         ▼
    ┌────────────┐
    │  tinywasm  │  ← Handles WASM compilation
    │  Compile   │     (Go/TinyGo modes: c/d/p)
    └─────┬──────┘
          │
          ▼
    ┌──────────┐
    │ app.wasm │
    └─────┬────┘
          │
          ▼
    ┌────────────────────┐
    │     goflare        │  ← Generates JS wrappers
    │ GenerateXXXFiles() │
    └──────────┬─────────┘
               │
        ┌──────┴───────┐
        ▼              ▼
   Workers Mode    Pages Mode
```

## Core Components

### 1. WASM Compilation (tinywasm)
- **Input**: Go source code
- **Output**: `app.wasm`
- **Modes**:
  - `c` (coding): Fast Go standard compiler
  - `d` (debug): TinyGo with debug symbols
  - `p` (production): TinyGo optimized/minimal size

### 2. Runtime Files (Generated by goflare)

#### Common Files (Both Workers & Pages)
| File | Purpose | Source |
|------|---------|--------|
| `wasm_exec.js` | WebAssembly runtime (Go class) | Go/TinyGo toolchain |
| `runtime.mjs` | Cloudflare context provider | Generated template |
| `worker.mjs` | Main worker logic | Generated template |
| `app.wasm` | Compiled Go binary | tinywasm output |

#### Workers-Specific
- **Entry Point**: `worker.mjs` (in deploy directory)
- **Exports**: `default { fetch, scheduled, queue }`

#### Pages-Specific (Advanced Mode)
- **Entry Point**: `_worker.js` (in pages directory)
- **Exports**: `default { fetch }`
- **Additional**: 
  - `env.ASSETS.fetch()` for serving static files
  - Static files in same directory as `_worker.js`

## Build Process Comparison

### Workers (`GenerateWorkerFiles()`)

```
1. Create output directory (e.g., deploy/)
2. Compile WASM via tinywasm → app.wasm
3. Copy wasm_exec.js (mode-specific)
4. Generate runtime.mjs (Cloudflare APIs)
5. Generate worker.mjs (main entry point)
   └─ Exports: fetch, scheduled, queue
```

**Output Structure:**
```
deploy/
├── app.wasm
├── wasm_exec.js
├── runtime.mjs
└── worker.mjs
```

### Pages (`GeneratePagesFiles()`)

```
1. Create output directory (pages/)
2. Compile WASM via tinywasm → pages/app.wasm
3. Generate combined _worker.js (contains ALL JS code inline)
   ├─ Includes: wasm_exec.js + runtime.mjs + worker logic
   ├─ Configurable API prefix (default: "/api/")
   ├─ Configurable WASM filename (default: "app.wasm")
   ├─ Routes API requests to Go WASM handlers
   └─ Routes static requests to env.ASSETS.fetch()
```

**Output Structure:**
```
pages/
├── _worker.js     # Combined file with all JavaScript code inline
└── app.wasm       # WASM binary
```

**Output Structure:**
```
pages/
├── _worker.js       # Advanced Mode entry point (combined JS)
├── app.wasm
└── index.html       # Optional static files
```

## File Templates

### runtime.mjs (Common)
```javascript
import { connect } from "cloudflare:sockets";
import mod from "./app.wasm";

export async function loadModule() {
  return mod;
}

export function createRuntimeContext({ env, ctx, binding }) {
  return {
    env,
    ctx,
    connect,
    binding,
  };
}
```

### worker.mjs (Workers)
```javascript
import "./wasm_exec.js";
import { createRuntimeContext, loadModule } from "./runtime.mjs";

let mod;

globalThis.tryCatch = (fn) => { /* ... */ };

async function run(ctx) { /* ... */ }

async function fetch(req, env, ctx) { /* ... */ }
async function scheduled(event, env, ctx) { /* ... */ }
async function queue(batch, env, ctx) { /* ... */ }

export default { fetch, scheduled, queue };
```

### worker.mjs (Pages - Advanced Mode)
```javascript
import "./wasm_exec.js";
import { createRuntimeContext, loadModule } from "./runtime.mjs";

let mod;

globalThis.tryCatch = (fn) => { /* ... */ };

async function run(ctx) { /* ... */ }

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // Route API requests to Go WASM handlers
    if (url.pathname.startsWith("/api/")) {
      const binding = {};
      await run(createRuntimeContext({ env, ctx, binding }));
      return binding.handleRequest(request);
    }
    
    // Serve static assets for all other requests
    // CRITICAL: Without this, static files will not be served
    return env.ASSETS.fetch(request);
  }
};
```

## Key Design Decisions

### 1. Mode-Specific wasm_exec.js
- Go and TinyGo provide different `wasm_exec.js` implementations
- GoFlare must detect the tinywasm compilation mode
- Copy the appropriate version for each build

### 2. Module Instantiation Pattern
```javascript
const instance = new WebAssembly.Instance(mod, {
  ...go.importObject,
  workers: {
    ready: () => { ready(); }
  }
});
```
- Uses synchronous instantiation (not streaming)
- Requires pre-compiled module from `loadModule()`
- Registers `workers.ready()` callback

### 3. Singleton Module Pattern
```javascript
let mod;
if (mod === undefined) {
  mod = await loadModule();
}
```
- Cache module across requests (Workers/Pages)
- First request compiles, subsequent reuse
- Reduces cold start overhead

### 4. Binding Pattern
```javascript
const binding = {};
await run(createRuntimeContext({ env, ctx, binding }));
return binding.handleRequest(req);
```
- Go code registers handlers in `binding` object
- JavaScript calls through binding after WASM init
- Enables Go to control request handling

## Implementation Requirements

### Goflare Package Structure
```go
package goflare

import (
  _ "embed"
  "github.com/tinywasm/client"
)

//go:embed assets
var assets embed.FS

type Goflare struct {
  tw *tinywasm.TinyWasm
}

func (g *Goflare) GenerateWorkerFiles() error {
  // 1. Ensure directories exist
  // 2. Get wasm_exec.js for current mode
  // 3. Generate runtime.mjs from template
  // 4. Generate worker.mjs from template
  return nil
}

func (g *Goflare) GeneratePagesFiles() error {
  // 1. Ensure pages/ directory exists
  // 2. Get wasm_exec.js for current mode
  // 3. Generate pages/runtime.mjs
  // 4. Generate pages/_worker.js (Advanced Mode)
  //    - Handle /api/* routes via WASM
  //    - Fallback to env.ASSETS.fetch() for static files
  return nil
}
```

### Required Assets
```
goflare/
├── assets/
│   ├── runtime/
│   │   └── cloudflare.mjs         # Template for runtime.mjs
│   ├── common/
│   │   └── worker.mjs              # Template for Workers worker.mjs
│   └── pages/
│       └── worker.js               # Template for Pages _worker.js (Advanced Mode)
```

## Wrangler Configuration

### Workers (wrangler.toml)
```toml
name = "my-worker"
main = "./deploy/worker.mjs"
compatibility_date = "2023-04-30"
```

### Pages (wrangler.toml)
```toml
name = "my-pages-app"
compatibility_date = "2023-04-30"

# No configuration needed - wrangler auto-detects _worker.js
# Static files are served via env.ASSETS.fetch()
```

## Error Handling Strategy

Both methods should handle:
1. **Directory Creation Failures**: Return error if unable to create output directories
2. **WASM Compilation Failures**: Propagate tinywasm errors
3. **File Write Failures**: Return error with file path context
4. **Template Errors**: Return error if embedded assets missing
5. **Mode Detection Failures**: Return error if unable to determine compilation mode

## Testing Strategy

### Unit Tests
- Mock tinywasm instance
- Test template generation
- Verify file structure
- Test error conditions
- Mock HTTP server for CF API endpoints

### Integration Tests
- Compile actual Go WASM
- Generate all files
- Validate against wrangler
- Test deployment (local dev server)

## Auth & Deploy Flow

GoFlare includes built-in support for deploying directly to Cloudflare Pages via the Cloudflare API, without requiring the Wrangler CLI.

### 1. Authentication (Wizard)
- Cloudflare's API requires a user-generated "bootstrap token".
- GoFlare uses this bootstrap token once to programmatically generate a scoped `Pages:Edit` token.
- The scoped token and account details are stored securely in the system keyring.
- See the [AUTH_FLOW diagram](./diagrams/AUTH_FLOW.md).

### 2. Direct Deployment
- GoFlare reads the project details and scoped token from the keyring.
- It verifies the built payload containing `_worker.js` and compiled WASM.
- It performs a multipart/form-data upload directly to the Cloudflare Pages REST API.
- See the [DEPLOY_FLOW diagram](./diagrams/DEPLOY_FLOW.md).

## Future Enhancements

1. **Custom Templates**: Allow users to provide custom worker.mjs templates
2. **Module Bundling**: Integrate with esbuild for optimization
3. **Sourcemaps**: Generate sourcemaps for debugging
4. **Watch Mode**: Auto-regenerate on file changes

## References

- [Cloudflare Workers Documentation](https://developers.cloudflare.com/workers/)
- [Cloudflare Pages Functions](https://developers.cloudflare.com/pages/functions/)
- [WebAssembly Instantiation](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate)
- [syumai/workers Package](https://github.com/syumai/workers)
