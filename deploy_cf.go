package goflare

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
)

// DeployPages uploads the compiled WASM + JS wrapper to Cloudflare Pages
// using the Direct Upload API (no Wrangler CLI required).
//
// Reads account_id, pages_token, and pages_project from the keyring.
// Output files must have been generated by GeneratePagesFiles() first.
func (g *Goflare) DeployPages() error {
	if g.auth == nil {
		return fmt.Errorf("goflare: auth not configured — call SetKeys first")
	}

	token, err := g.auth.PagesToken()
	if err != nil {
		return fmt.Errorf("goflare: pages token not found — run setup wizard first")
	}

	accountID, err := g.auth.AccountID()
	if err != nil {
		return fmt.Errorf("goflare: account_id not found — run setup wizard first")
	}

	projectName, err := g.auth.ProjectName()
	if err != nil {
		return fmt.Errorf("goflare: project name not found — run setup wizard first")
	}

	outputDir := g.config.RelativeOutputDirectory()
	if !filepath.IsAbs(outputDir) {
		outputDir = filepath.Join(g.config.AppRootDir, outputDir)
	}

	jsFile := filepath.Join(outputDir, g.outputJsFileName)
	wasmFile := filepath.Join(outputDir, g.config.OutputWasmFileName)

	g.Logger("Deploying to Cloudflare Pages project:", projectName)

	if err := g.uploadToPages(token, accountID, projectName, jsFile, wasmFile); err != nil {
		return fmt.Errorf("goflare: upload failed: %w", err)
	}

	g.Logger("Cloudflare Pages deployment complete.")
	return nil
}

// uploadToPages builds a multipart/form-data request with all output files
// and posts it to the Cloudflare Pages Direct Upload endpoint.
func (g *Goflare) uploadToPages(token, accountID, project, jsFile, wasmFile string) error {
	var buf bytes.Buffer
	mw := multipart.NewWriter(&buf)

	if err := addFilePart(mw, "_worker.js", jsFile); err != nil {
		return fmt.Errorf("add _worker.js: %w", err)
	}
	if err := addFilePart(mw, g.config.OutputWasmFileName, wasmFile); err != nil {
		return fmt.Errorf("add %s: %w", g.config.OutputWasmFileName, err)
	}

	if err := mw.Close(); err != nil {
		return err
	}

	url := fmt.Sprintf("%s/accounts/%s/pages/projects/%s/deployments",
		g.cfDeployBaseURL, accountID, project)

	req, err := http.NewRequest(http.MethodPost, url, &buf)
	if err != nil {
		return err
	}
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", mw.FormDataContentType())

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("POST deployments: %w", err)
	}
	defer resp.Body.Close()

	data, _ := io.ReadAll(resp.Body)

	var envelope cfResponse
	if err := json.Unmarshal(data, &envelope); err != nil {
		return fmt.Errorf("parse response: %w", err)
	}
	if !envelope.Success {
		if len(envelope.Errors) > 0 {
			return fmt.Errorf("CF API error %d: %s", envelope.Errors[0].Code, envelope.Errors[0].Message)
		}
		return fmt.Errorf("CF API returned success=false")
	}

	// Log deployment URL from result
	var result struct {
		URL string `json:"url"`
	}
	if err := json.Unmarshal(envelope.Result, &result); err == nil && result.URL != "" {
		g.Logger("Deployment URL:", result.URL)
	}

	return nil
}

func addFilePart(mw *multipart.Writer, fieldName, filePath string) error {
	f, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("open %s: %w", filePath, err)
	}
	defer f.Close()

	part, err := mw.CreateFormFile(fieldName, filepath.Base(filePath))
	if err != nil {
		return err
	}
	_, err = io.Copy(part, f)
	return err
}
